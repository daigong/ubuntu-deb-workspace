<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a>      </li>
      <li class="navelem"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::QueryParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Xapian::QueryParser" -->
<p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string.  
 <a href="classXapian_1_1QueryParser.html#details">More...</a></p>

<p><a href="classXapian_1_1QueryParser-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">feature_flag</a> { <br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde">FLAG_BOOLEAN</a> =  1, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b">FLAG_PHRASE</a> =  2, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd">FLAG_LOVEHATE</a> =  4, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d">FLAG_BOOLEAN_ANY_CASE</a> =  8, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a> =  16, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0">FLAG_PURE_NOT</a> =  32, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a> =  64, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c">FLAG_SPELLING_CORRECTION</a> =  128, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f">FLAG_SYNONYM</a> =  256, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b">FLAG_AUTO_SYNONYMS</a> =  512, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b">FLAG_AUTO_MULTIWORD_SYNONYMS</a> =  1024, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a> =  FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stemming strategies, for use with <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d9afcf20b20cd9c8b3d22dd1bc82b7"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="a00d9afcf20b20cd9c8b3d22dd1bc82b7" args="(const QueryParser &amp;o)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a00d9afcf20b20cd9c8b3d22dd1bc82b7">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18adb637032c2149a0457f2f79f332a5"></a><!-- doxytag: member="Xapian::QueryParser::operator=" ref="a18adb637032c2149a0457f2f79f332a5" args="(const QueryParser &amp;o)" -->
<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a18adb637032c2149a0457f2f79f332a5">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724f1e26b785516c4c8cde78455f9cd5"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="a724f1e26b785516c4c8cde78455f9cd5" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a724f1e26b785516c4c8cde78455f9cd5">QueryParser</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d48b819b0c6d6a29f86a756f91d047"></a><!-- doxytag: member="Xapian::QueryParser::~QueryParser" ref="a69d48b819b0c6d6a29f86a756f91d047" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a69d48b819b0c6d6a29f86a756f91d047">~QueryParser</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2312c9865a58cc1149fe7cda9f0c2585">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemmer.  <a href="#a2312c9865a58cc1149fe7cda9f0c2585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd">set_stemming_strategy</a> (<a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemming strategy.  <a href="#ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ab1046610676f72ba564108f0df5d77ab">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stopper.  <a href="#ab1046610676f72ba564108f0df5d77ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2efe48be88c4872afec4bc963f417ea5">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> default_op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default operator.  <a href="#a2efe48be88c4872afec4bc963f417ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a4a6323a8aea7734e447de1ba7eab31c1">get_default_op</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default operator.  <a href="#a4a6323a8aea7734e447de1ba7eab31c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the database being searched.  <a href="#a576d221ba746506e51d9ea596ecb2cf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a7651d48cdc661c0605c475925170cc71">set_max_wildcard_expansion</a> (<a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard term.  <a href="#a7651d48cdc661c0605c475925170cc71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2">parse_query</a> (const std::string &amp;query_string, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a>, const std::string &amp;default_prefix=std::string())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a query.  <a href="#a73d32cc7f862ab2e3fdd7da61f352fb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a probabilistic term prefix.  <a href="#ad4829ddcaa0582ff94d1066870a18c97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a3c6b58293a8e0e0d1db354362c5b7e19">add_prefix</a> (const std::string &amp;field, <a class="el" href="structXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a>.  <a href="#a3c6b58293a8e0e0d1db354362c5b7e19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a69547207acb0cf6f3eebbad1d7dcdba4">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, bool exclusive=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#a69547207acb0cf6f3eebbad1d7dcdba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2dbefca2d5c269bf57f61189d84c8303">add_boolean_prefix</a> (const std::string &amp;field, <a class="el" href="structXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc, bool exclusive=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a> for a boolean prefix.  <a href="#a2dbefca2d5c269bf57f61189d84c8303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57ff03cd3fe1fa2b6e07fc347bee3590"></a><!-- doxytag: member="Xapian::QueryParser::stoplist_begin" ref="a57ff03cd3fe1fa2b6e07fc347bee3590" args="() const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a57ff03cd3fe1fa2b6e07fc347bee3590">stoplist_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over terms omitted from the query as stopwords. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2088e54f557e2d608247c5237a1bc3b"></a><!-- doxytag: member="Xapian::QueryParser::unstem_begin" ref="aa2088e54f557e2d608247c5237a1bc3b" args="(const std::string &amp;term) const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#aa2088e54f557e2d608247c5237a1bc3b">unstem_begin</a> (const std::string &amp;term) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over unstemmed forms of the given (stemmed) term used in the query. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8583a9f044f2eb33859b442a8aea76"></a><!-- doxytag: member="Xapian::QueryParser::add_valuerangeprocessor" ref="a8f8583a9f044f2eb33859b442a8aea76" args="(Xapian::ValueRangeProcessor *vrproc)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8f8583a9f044f2eb33859b442a8aea76">add_valuerangeprocessor</a> (<a class="el" href="structXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a">get_corrected_query_string</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#a0e59c760a0a4edacb437621ac66be25a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f9d15f38538a07497fdfc8658852b2"></a><!-- doxytag: member="Xapian::QueryParser::get_description" ref="a89f9d15f38538a07497fdfc8658852b2" args="() const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a89f9d15f38538a07497fdfc8658852b2">get_description</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407e"></a><!-- doxytag: member="Xapian::QueryParser::feature_flag" ref="ae96a58a8de9d219ca3214a5a66e0407e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">Xapian::QueryParser::feature_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enum of feature flags. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde"></a><!-- doxytag: member="FLAG_BOOLEAN" ref="ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde" args="" -->FLAG_BOOLEAN</em>&nbsp;</td><td>
<p>Support AND, OR, etc and bracketed subexpressions. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b"></a><!-- doxytag: member="FLAG_PHRASE" ref="ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b" args="" -->FLAG_PHRASE</em>&nbsp;</td><td>
<p>Support quoted phrases. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd"></a><!-- doxytag: member="FLAG_LOVEHATE" ref="ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd" args="" -->FLAG_LOVEHATE</em>&nbsp;</td><td>
<p>Support + and -. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d"></a><!-- doxytag: member="FLAG_BOOLEAN_ANY_CASE" ref="ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d" args="" -->FLAG_BOOLEAN_ANY_CASE</em>&nbsp;</td><td>
<p>Support AND, OR, etc even if they aren't in ALLCAPS. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36"></a><!-- doxytag: member="FLAG_WILDCARD" ref="ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36" args="" -->FLAG_WILDCARD</em>&nbsp;</td><td>
<p>Support right truncation (e.g. </p>
<p>Xap*).</p>
<p>Currently you can't use wildcards with boolean filter prefixes, or in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation).</p>
<p>NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0"></a><!-- doxytag: member="FLAG_PURE_NOT" ref="ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0" args="" -->FLAG_PURE_NOT</em>&nbsp;</td><td>
<p>Allow queries such as 'NOT apples'. </p>
<p>These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7"></a><!-- doxytag: member="FLAG_PARTIAL" ref="ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7" args="" -->FLAG_PARTIAL</em>&nbsp;</td><td>
<p>Enable partial matching. </p>
<p>Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.</p>
<p>Currently FLAG_PARTIAL doesn't do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn't do anything if if the final word is part of a value range.</p>
<p>NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c"></a><!-- doxytag: member="FLAG_SPELLING_CORRECTION" ref="ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c" args="" -->FLAG_SPELLING_CORRECTION</em>&nbsp;</td><td>
<p>Enable spelling correction. </p>
<p>For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#a86b944dece96d7ada2446ae8952ee3a2" title="Suggest a spelling correction.">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a" title="Get the spelling-corrected query string.">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> again.</p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f"></a><!-- doxytag: member="FLAG_SYNONYM" ref="ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f" args="" -->FLAG_SYNONYM</em>&nbsp;</td><td>
<p>Enable synonym operator '~'. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b"></a><!-- doxytag: member="FLAG_AUTO_SYNONYMS" ref="ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b" args="" -->FLAG_AUTO_SYNONYMS</em>&nbsp;</td><td>
<p>Enable automatic use of synonyms for single terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b"></a><!-- doxytag: member="FLAG_AUTO_MULTIWORD_SYNONYMS" ref="ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b" args="" -->FLAG_AUTO_MULTIWORD_SYNONYMS</em>&nbsp;</td><td>
<p>Enable automatic use of synonyms for single terms and groups of terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a"></a><!-- doxytag: member="FLAG_DEFAULT" ref="ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a" args="" -->FLAG_DEFAULT</em>&nbsp;</td><td>
<p>The default flags. </p>
<p>Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></em>. The default flags are FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE.</p>
<p>Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.0.11. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a69547207acb0cf6f3eebbad1d7dcdba4"></a><!-- doxytag: member="Xapian::QueryParser::add_boolean_prefix" ref="a69547207acb0cf6f3eebbad1d7dcdba4" args="(const std::string &amp;field, const std::string &amp;prefix, bool exclusive=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a69547207acb0cf6f3eebbad1d7dcdba4">Xapian::QueryParser::add_boolean_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">  qp.add_boolean_prefix(<span class="stringliteral">&quot;site&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>);
</pre></div><p>This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <code>Xapian::Query::OP_FILTER</code>.</p>
<p>If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code>Xapian::Query::OP_OR</code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code>Xapian::Query::OP_AND</code> operator.</p>
<p>Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.</p>
<p>For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>Calling this method with an empty string for <em>field</em> will cause a <code><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></code>.</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a69547207acb0cf6f3eebbad1d7dcdba4" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
    <tr><td class="paramname">exclusive</td><td>If true, each document can have at most one term with this prefix, so multiple filters with this prefix should be combined with OP_OR. If false, each document can have multiple terms with this prefix, so multiple filters should be combined with OP_AND, like happens with filters with different prefixes. [default: true] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dbefca2d5c269bf57f61189d84c8303"></a><!-- doxytag: member="Xapian::QueryParser::add_boolean_prefix" ref="a2dbefca2d5c269bf57f61189d84c8303" args="(const std::string &amp;field, Xapian::FieldProcessor *proc, bool exclusive=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a69547207acb0cf6f3eebbad1d7dcdba4">Xapian::QueryParser::add_boolean_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a <a class="el" href="structXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a> for a boolean prefix. </p>
<p>Experimental API - may change. </p>

</div>
</div>
<a class="anchor" id="ad4829ddcaa0582ff94d1066870a18c97"></a><!-- doxytag: member="Xapian::QueryParser::add_prefix" ref="ad4829ddcaa0582ff94d1066870a18c97" args="(const std::string &amp;field, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">Xapian::QueryParser::add_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a probabilistic term prefix. </p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">  qp.add_prefix(<span class="stringliteral">&quot;author&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);
</pre></div><p>This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".</p>
<p>Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.</p>
<p>If the prefix parameter is empty, then "field:word" will produce the term "word" (and this can be one of several prefixes for a particular field, or for terms without a field specifier).</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a69547207acb0cf6f3eebbad1d7dcdba4" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c6b58293a8e0e0d1db354362c5b7e19"></a><!-- doxytag: member="Xapian::QueryParser::add_prefix" ref="a3c6b58293a8e0e0d1db354362c5b7e19" args="(const std::string &amp;field, Xapian::FieldProcessor *proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">Xapian::QueryParser::add_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *&#160;</td>
          <td class="paramname"><em>proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a <a class="el" href="structXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a>. </p>
<p>Experimental API - may change. </p>

</div>
</div>
<a class="anchor" id="a0e59c760a0a4edacb437621ac66be25a"></a><!-- doxytag: member="Xapian::QueryParser::get_corrected_query_string" ref="a0e59c760a0a4edacb437621ac66be25a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a">Xapian::QueryParser::get_corrected_query_string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the spelling-corrected query string. </p>
<p>This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> was last called.</p>
<p>If there were no corrections, an empty string is returned. </p>

</div>
</div>
<a class="anchor" id="a4a6323a8aea7734e447de1ba7eab31c1"></a><!-- doxytag: member="Xapian::QueryParser::get_default_op" ref="a4a6323a8aea7734e447de1ba7eab31c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> <a class="el" href="classXapian_1_1QueryParser.html#a4a6323a8aea7734e447de1ba7eab31c1">Xapian::QueryParser::get_default_op</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current default operator. </p>

</div>
</div>
<a class="anchor" id="a73d32cc7f862ab2e3fdd7da61f352fb2"></a><!-- doxytag: member="Xapian::QueryParser::parse_query" ref="a73d32cc7f862ab2e3fdd7da61f352fb2" args="(const std::string &amp;query_string, unsigned flags=FLAG_DEFAULT, const std::string &amp;default_prefix=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2">Xapian::QueryParser::parse_query</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_prefix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a query. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query_string</td><td>A free-text query as entered by a user </td></tr>
    <tr><td class="paramname">flags</td><td>Zero or more Query::feature_flag specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td class="paramname">default_prefix</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the query string can't be parsed, then <a class="el" href="classXapian_1_1QueryParserError.html" title="Indicates a query string can&#39;t be parsed.">Xapian::QueryParserError</a> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Unknown range operation </li>
<li>parse error </li>
<li>Syntax: &lt;expression&gt; AND &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; AND NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; OR &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; XOR &lt;expression&gt; </li>
</ul>

</div>
</div>
<a class="anchor" id="a576d221ba746506e51d9ea596ecb2cf6"></a><!-- doxytag: member="Xapian::QueryParser::set_database" ref="a576d221ba746506e51d9ea596ecb2cf6" args="(const Database &amp;db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6">Xapian::QueryParser::set_database</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the database being searched. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>The database to use for wildcard expansion (FLAG_WILDCARD and FLAG_PARTIAL), spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2efe48be88c4872afec4bc963f417ea5"></a><!-- doxytag: member="Xapian::QueryParser::set_default_op" ref="a2efe48be88c4872afec4bc963f417ea5" args="(Query::op default_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a2efe48be88c4872afec4bc963f417ea5">Xapian::QueryParser::set_default_op</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td>
          <td class="paramname"><em>default_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">default_op</td><td>The operator to use to combine non-filter query items when no explicit operator is used.</td></tr>
  </table>
  </dd>
</dl>
<p>So for example, 'weather forecast' is parsed as if it were 'weather OR forecast' by default.</p>
<p>The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR, OP_PHRASE, OP_ELITE_SET and OP_SYNONYM are also permitted. Passing other values will result in <a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">InvalidArgumentError</a> being thrown. </p>

</div>
</div>
<a class="anchor" id="a7651d48cdc661c0605c475925170cc71"></a><!-- doxytag: member="Xapian::QueryParser::set_max_wildcard_expansion" ref="a7651d48cdc661c0605c475925170cc71" args="(Xapian::termcount limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a7651d48cdc661c0605c475925170cc71">Xapian::QueryParser::set_max_wildcard_expansion</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the maximum expansion of a wildcard term. </p>
<p>Note: you must also set FLAG_WILDCARD for wildcard expansion to happen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2312c9865a58cc1149fe7cda9f0c2585"></a><!-- doxytag: member="Xapian::QueryParser::set_stemmer" ref="a2312c9865a58cc1149fe7cda9f0c2585" args="(const Xapian::Stem &amp;stemmer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#a2312c9865a58cc1149fe7cda9f0c2585">Xapian::QueryParser::set_stemmer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&#160;</td>
          <td class="paramname"><em>stemmer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the stemmer. </p>
<p>This sets the stemming algorithm which will be used by the query parser. The stemming algorithm will be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>. As of 1.3.1, this defaults to STEM_SOME, but in earlier versions the default was STEM_NONE. If you want to work with older versions, you should explicitly set a stemming strategy as well as setting a stemmer, otherwise your stemmer won't actually be used.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stemmer</td><td>The <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Xapian::Stem</a> object to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a><!-- doxytag: member="Xapian::QueryParser::set_stemming_strategy" ref="ac7dc3b55b6083bd3ff98fc8b2726c8fd" args="(stem_strategy strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd">Xapian::QueryParser::set_stemming_strategy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the stemming strategy. </p>
<p>This controls how the query parser will apply the stemming algorithm. Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The strategy to use - possible values are:<ul>
<li>STEM_NONE: Don't perform any stemming. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &lt;= 1.3.0)</li>
<li>STEM_SOME: Search for stemmed forms of terms except for those which start with a capital letter, or are followed by certain characters (currently: (/@&lt;&gt;=*[{" ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &gt;= 1.3.1)</li>
<li>STEM_ALL: Search for stemmed forms of all words (note: no 'Z' prefix is added).</li>
<li>STEM_ALL_Z: Search for stemmed forms of all words (note: 'Z' prefix is added). (new in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.11 and 1.3.1) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1046610676f72ba564108f0df5d77ab"></a><!-- doxytag: member="Xapian::QueryParser::set_stopper" ref="ab1046610676f72ba564108f0df5d77ab" args="(const Stopper *stop=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classXapian_1_1QueryParser.html#ab1046610676f72ba564108f0df5d77ab">Xapian::QueryParser::set_stopper</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&#160;</td>
          <td class="paramname"><em>stop</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the stopper. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>The <a class="el" href="classXapian_1_1Stopper.html" title="Base class for stop-word decision functor.">Stopper</a> object to set (default NULL, which means no stopwords). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="queryparser_8h.html">queryparser.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.3.1).<br>
Generated on Fri May 3 2013 by
<a href="http://www.doxygen.org/">Doxygen 1.7.6.1</a>.
</small></address>
</body>
</html>
