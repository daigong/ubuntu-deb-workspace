#encoding:utf-8
from gevent import monkey
monkey.patch_all()

import gevent
import socket
import logging
from Crypto.Cipher import AES

logger = logging.getLogger()


class StromClient(object):
        #session的aes加密Key
    key = '$9Zz\xee\xb4h\xa8\xf4h\x01g8\x19\xffc'
    # 超时时间单位秒    
    timeout=60*4
    #最大接受字节数
    MAX_LENGTH = 1048576

    def __init__(self, addr, port):
        self.addr = addr
        self.port = port
        self._connected = False
        self.__buffer = ''
        self.sock = None

    def connect(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    try:
	    	self.sock.connect((self.addr, self.port))
	    except Exception as e:
		import sys
		return False
            recv_data = self.sock.recv(32)
            ivParameterSpec = recv_data[:16]
            session_id = recv_data[16:]
            decryptor = AES.new(self.key, AES.MODE_CBC, ivParameterSpec)
            session_id = decryptor.decrypt(session_id)
            self.delimiter = session_id
            self.sock.sendall(session_id)
            self._connected = True
            return True
        except BaseException as e:
            logger.exception(e)
	except SystemExit as e2:
	    pass
        return False

    def disconnect(self):
        try:
            if self.sock:
                self.sock.close()
                del self.sock
            self.sock = None
        except socket.error as error:
            logger.exception(error)
        self._connected = False

    def reconnect(self):
        self.disconnect()
        return self.connect()

    def sendLine(self, line):
        if not self._connected:
            self.connect()
        self.sock.sendall(line + self.delimiter)
        gevent.sleep(0)

    def lineReceived(self, size=1024):
        """
        Translates bytes into lines,and calls lineHandle
        """
        if not self._connected:self.connect()#如果没有连接则连接
        lines = None
        while True:
            if lines:return lines.pop(0)
            raw = None
            with gevent.Timeout(self.timeout, False):
                raw = self.sock.recv(size)
            if not raw:return raw#空值证明超时
            self.__buffer = self.__buffer + raw
            line_split = self.__buffer.split(self.delimiter)
            if len(line_split) > 1:
                self.__buffer = line_split[-1]
                lines = line_split[:-1]
            elif len(self.__buffer) > self.MAX_LENGTH:
                break
            gevent.sleep(0)



class StromQCommond:
    
    def __init__(self, addr, port):
        self.client = StromClient(addr,port)
        self.subscribe_table = set()#订阅列表

    def subscribe(self,channel):
        try:
            self.subscribe_table.add(channel)
            self.client.sendLine("SUBSCRIBE:%s" % channel)
        except socket.error as error:
            self.resubscribe()
            self.client.sendLine("SUBSCRIBE:%s" % channel)
            logger.exception(error)

    def unsubscribe(self,channel):
        try:
            self.client.sendLine("UNSUBSCRIBE:%s" % channel)
            self.subscribe_table.remove(channel)
        except socket.error as error:
            self.resubscribe()
            self.client.sendLine("UNSUBSCRIBE:%s" % channel)
            self.subscribe_table.remove(channel)
            logger.exception(error)
        
    def publish(self, channel, context, expire=86400):
        try:
            self.client.sendLine("PUBLISH %d:%s@%s" % (expire,context,channel))
        except socket.error as error:
            logger.exception(error)
            self.resubscribe()
            self.client.sendLine("PUBLISH %d:%s@%s" % (expire,context,channel))

    def resubscribe(self):
        self.client.reconnect()
        for channel in self.subscribe_table:
            self.subscribe(channel)

    def close(self):
        self.client.disconnect()

class PubSubClient(StromQCommond):
    
    def __init__(self, addr, port, transient=True):
        StromQCommond.__init__(self, addr, port)
        if not transient:
            gevent.spawn_link(self.heartbeat)

    def heartbeat(self):
        while True:
            gevent.sleep(self.client.timeout-30)
            try:
                self.client.sendLine('^')
            except socket.error as error:
                self.client.reconnect()
                logger.exception(error)
    
    def listen(self):
        while True:
            line = self.client.lineReceived()
            if line and len(line) > 1:
                yield line
            elif line and len(line) == 1:#心跳包
                logger.debug('receive a heart.')
            else:
                self.resubscribe()
                    
    def __enter__(self):
        return self

    def __exit__(self, _type, value, traceback):
        self.close()
    
class PushClient:

    def __init__(self, addr, port,transient=True):
        self.client = StromClient(addr,port)
        if not transient:
            gevent.spawn(self.heartbeat)

    def heartbeat(self):
        while True:
            gevent.sleep(self.client.timeout-30)
            try:
                self.client.sendLine('^')
                self.client.lineReceived()
            except socket.error as error:
                self.client.reconnect()
                logger.exception(error)
    
    def push(self,data):
        try:
            self.client.sendLine(data)
        except socket.error as error:
            logger.exception(error)
            self.client.reconnect()
            self.client.sendLine(data)

    def close(self):
        self.client.disconnect()

    def __enter__(self):
        return self

    def __exit__(self, _type, value, traceback):
        self.close()

class ReqResClient:

    def __init__(self, addr, port,transient=True):
        self.client = StromClient(addr,port)
        if not transient:
            gevent.spawn(self.heartbeat)

    def heartbeat(self):
        while True:
            gevent.sleep(self.client.timeout-30)
            try:
                self.client.sendLine('^')
            except socket.error as error:
                self.client.reconnect()
                logger.exception(error)

    def get(self, data):
        try:
            self.client.sendLine(data)
        except socket.error as error:
            logger.exception(error)
            self.client.reconnect()
            self.client.sendLine(data)
        line = self.client.lineReceived()
        if not line:return line
        while len(line) == 1:#心跳包
            logger.debug('receive a heart.')
            line = self.client.lineReceived()
        else:
            return line

    def close(self):
        self.client.disconnect()

    def __enter__(self):
        return self

    def __exit__(self, _type, value, traceback):
        self.close()

def open(url,transient=True):
    try:
	    params = url.split("://")
	    host, port=params[1].split(":")
	    if 'psp' == params[0]:
		return PubSubClient(host, int(port), transient)
	    elif 'ppp' == params[0]:
		return PushClient(host, int(port), transient)
	    elif 'rrp' == params[0]:
		r = ReqResClient(host, int(port), transient)
		return r
	    else:
		raise ValueError('does not support this protocol(%s)' % params[0])
    except Exception as e:
	pass
