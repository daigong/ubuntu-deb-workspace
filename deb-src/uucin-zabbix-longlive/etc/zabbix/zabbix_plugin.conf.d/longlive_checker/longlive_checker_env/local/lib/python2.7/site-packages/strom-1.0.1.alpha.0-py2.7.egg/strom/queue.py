#encoding:utf-8
import logging
import gevent
import socket
from Crypto.Cipher import AES
from .handler import AuthHandler
from .server import StromServer
from .client import PushClient
from gevent.queue import Queue
from persistence import get_persistence,NonePersistence
logger = logging.getLogger()

class QueueHandler(AuthHandler):

    def __init__(self, request, client_address, server):
        AuthHandler.__init__(self, request, client_address, server)
        self.channels = set()

    def lineReceived(self, line):
        logger.debug("received %s" % line)
        commond, line = line.split(':', 1)
        if commond.startswith('SUBSCRIBE'):  #订阅,并发送持久化消息
            self.subscribe(line)
            self.publish(line,None)
        elif commond.startswith('UNSUBSCRIBE'):  # 取消订阅
            self.unsubscribe(line)
        elif commond.startswith('PUBLISH'):  # 将发布广播出去 
            expire = int(commond.split(' ')[1])#第一个参数是过期时间
            context, channel=line.rsplit('@',1)
            self.server.persistence.set(channel,context,expire)
            self.broadcast(line)
        elif commond.startswith('BROADCAST'):  # 接收广播
            context, channel=line.rsplit('@',1)
            self.publish(channel, context)
        else:  # 指令错误关闭客户端
            raise ValueError("commond error")

    def subscribe(self, line):
        if not line or line in self.channels:
            return
        self.channels.add(line)
        subscribers = None
        if line in self.server.subscribers:
            subscribers = self.server.subscribers[line]
        else:
            subscribers = set()
            self.server.subscribers[line] = subscribers
        subscribers.add(self)

    def unsubscribe(self, line):
        if not line or line not in self.channels:
            return
        self.channels.remove(line)
        subscribers = self.server.subscribers[line]
        subscribers.remove(self)
        if not subscribers:
            del self.server.subscribers[line]

    def publish(self, channel, context):
        if not context or not channel or channel not in self.server.subscribers:
            return
        subscribers = self.server.subscribers[channel]
        if not subscribers:
            return
        if isinstance(self.server.persistence,NonePersistence):
            self._notice_subscriber(context,subscribers)
        else:
            for msg in self.server.persistence.get(channel):
                self._notice_subscriber(msg,subscribers)

    def _notice_subscriber(self, context, subscribers):
        """
        将消息通知个所有订阅该消息的人
        """
        for subscriber in subscribers:
            try:
                subscriber.sendLine(context)
            except BaseException as e:
                logger.debug(e)

    def broadcast(self,line):
        self.server.broadcast(line)

    def destroy(self):
        for channel in self.channels:
            if channel not in self.server.subscribers:
                continue
            subscribers = self.server.subscribers[channel]
            subscribers.remove(self)
            if not subscribers:
                del self.server.subscribers[channel]
        AuthHandler.destroy(self)


class StromQueueServer(StromServer):

    def __init__(self, listener,config=None):
        self.subscribers = {}  # 存储所以订阅者
        self.cluster = []
        if config:
            StromServer.__init__(self,listener,request_handler=QueueHandler,config=config)
        else:
            StromServer.__init__(self,listener,request_handler=QueueHandler)
        self.queue = Queue()
        gevent.spawn(self.broadcast_task)

    def configure(self, cfg):
        StromServer.configure(self, cfg)
        PushClient.key = self.key
        PushClient.timeout = cfg.getfloat('queue','heartbeat_cycle_time')
        QueueHandler.timeout = cfg.getfloat('strom','max_timeout')
        server_nodes = []
        for node in cfg.items("queue"):
            if node[0].startswith('queue_node.'):
                host, port = node[1].split(":")
                self.cluster.append(PushClient(host, int(port), False))
            elif node[0].startswith('persistence_server_node.'):
                server_nodes.append(node[1])
        backend = cfg.get('queue','persistence_backend')
        self.persistence = get_persistence(server_nodes,backend) 

    def broadcast_task(self):
        while True:
            try:
                line = self.queue.get()
                for node in self.cluster:
                    try:
                        node.push("BROADCAST:%s" % line)
                    except BaseException as e:
                        logger.exception(e)
            except BaseException as e:
                logger.exception(e)

    def broadcast(self,line):
        self.queue.put(line)

