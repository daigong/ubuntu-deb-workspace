from gevent import monkey
monkey.patch_all()

import os
import logging
import contextlib
import ConfigParser
from multiprocessing import Process
from gevent.server import StreamServer

logger = logging.getLogger()
here = os.path.abspath(os.path.dirname(__file__))

class BaseRequestHandler:

    """Base class for request handler classes.

    This class is instantiated for each request to be handled.  The
    constructor sets the instance variables request, client_address
    and server, and then calls the handle() method.  To implement a
    specific service, all you need to do is to derive a class which
    defines a handle() method.

    The handle() method can find the request as self.request, the
    client address as self.client_address, and the server (in case it
    needs access to per-server information) as self.server.  Since a
    separate instance is created for each request, the handle() method
    can define arbitrary other instance variariables.

    """

    def __init__(self, request, client_address, server):
        self.request = request
        self.client_address = client_address
        self.server = server

    def setup(self):
        """
        The start handler must perform setup method
        """
        pass

    def handle(self):
        pass

    def finish(self):
        """
        If the successful execution of the handler, will run this method
        """
        pass

    def destroy(self):
        """
        Called after this handler lifecycle,this method does not allow an exception is thrown.
        """
        pass

class BaseServer(StreamServer):
    
    def __init__(self, listener, request_handler=None, backlog=None, spawn='default', **ssl_args):
        StreamServer.__init__(self,listener,handle=None,backlog=backlog,spawn=spawn,**ssl_args)
        self.request_handler=request_handler
        self.clients={}

    def start_request(self,request_handler,client_address):
        """
        Start a request,this method does not allow an exception is thrown.
        """
        logger.debug('start_request(%s:%s)' % client_address)

    def verify_request(self, request_handler, client_address):
        """
        Verify request,this method does not allow an exception is thrown.
        """
        logger.debug('verify_request(%s:%s)' % client_address)


    def handle(self,client_socket,client_address):
        with contextlib.closing(client_socket):
            request_handler = self.request_handler(client_socket,client_address,self)
            self.start_request(request_handler,client_address)
            self.verify_request(request_handler,client_address)
            try:            
                request_handler.setup()
                request_handler.handle()
                request_handler.finish()
            except BaseException as e:
                logger.exception(e) 
                self.handle_error(request_handler,client_address)
            finally:
                request_handler.destroy()
                self.close_request(request_handler,client_address)

    def handle_error(self, request_handler, client_address):
        """
        Handler is called when an exception occurs,this method does not allow an exception is thrown.
        """
        logger.debug('handle_error(%s:%s)' % client_address)  

    def close_request(self,request_handler, client_address):
        """
        Closing request called,this method does not allow an exception is thrown.
        """
        logger.debug('close_request(%s:%s)' % client_address)

class StromServer(BaseServer):

    def __init__(self, listener, request_handler, config = "%s/strom.ini" % here):
        BaseServer.__init__(self,listener,request_handler=request_handler)
        cfg = ConfigParser.ConfigParser()
        with open(config) as f:
            cfg.readfp(f)
        self.configure(cfg)

    def configure(self, cfg):
        key = eval("'%s'" % cfg.get('strom','key'))
        max_accept = cfg.getint('strom','max_connections')
        timeout = cfg.getfloat('strom','max_timeout')
        min_delay = cfg.getfloat('strom','min_delay')
        max_delay = cfg.getfloat('strom','max_delay')
        stop_timeout = cfg.getfloat('strom','stop_timeout')
        StromServer.key = key
        StromServer.max_accept = max_accept
        StromServer.min_delay = min_delay
        StromServer.max_delay = max_delay
        StromServer.stop_timeout = stop_timeout
        logging_config_path = cfg.get('strom','logging_config_path')
        logging_config_path = os.path.abspath(logging_config_path)
        if not os.path.exists(logging_config_path):
            if logging_config_path !='default':
                print('not have logging.cfg in the path:%s' % logging_config_path)
            logging_config_path = os.path.join(os.path.dirname(__file__),"logging.cfg")
        print('use logging config path:%s' % logging_config_path)
        logging.config.fileConfig(logging_config_path)
