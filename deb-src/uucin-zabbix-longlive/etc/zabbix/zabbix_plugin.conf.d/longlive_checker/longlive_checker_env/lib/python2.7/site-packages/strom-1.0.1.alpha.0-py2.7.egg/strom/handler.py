#encoding:utf-8
import random
import gevent
import logging
import socket
import random
from .server import BaseRequestHandler

logger = logging.getLogger()

import uuid
from Crypto.Cipher import AES


class LineHandler(BaseRequestHandler):

    ready = True
    __buffer = ''
    delimiter = '\r\n'
    timeout = 60 * 5
    MAX_LENGTH = 1048576

    def clearLineBuffer(self):
        """
        Clear buffered data.
        @return: All of the cleared buffered data.
        @rtype: C{str}
        """
        b = self.__buffer
        self.__buffer = ""
        return b

    def setTimeout(self, timeout):
        self.timeout = timeout

    def sendLine(self, line):
        self.request.sendall(line + self.delimiter)
        gevent.sleep(0)

    def handle(self):
        """
        socket handle
        """
        while self.ready:
            raw = None
            with gevent.Timeout(self.timeout, False):
                raw = self.request.recv(1024)
            if not raw:break
            self.__buffer = self.__buffer + raw
            line_split = self.__buffer.split(self.delimiter)
            if len(line_split) > 1:
                for line in line_split[:-1]:
                    if len(line) < 2:  # 心跳包
                        self.sendLine(line)
                    else:
                        self.lineReceived(line)
                del self.__buffer
                self.__buffer = line_split[-1]
            elif len(self.__buffer) > self.MAX_LENGTH:
                break
            gevent.sleep(0)

    def lineReceived(self, line):
        raise NotImplementedError()

    def finish(self):
        logger.debug('finish connection %s %d' % self.client_address)


class AuthHandler(LineHandler):
    
    def setup(self):
        """
        此处连接生成时执行
        """
        #初始化AES IV向量
        ivParameterSpec = ''.join(chr(random.randint(0,255)) for _ in range(16))
        encryptor = AES.new(self.server.key, AES.MODE_CBC, ivParameterSpec)
        self.setTimeout(self.timeout)
        session_id = uuid.uuid4().bytes  # 生成session ID,每个连接的结尾作为分割
        self.delimiter = session_id
        encrypt_session_id = encryptor.encrypt(session_id)
        self.request.sendall(ivParameterSpec + encrypt_session_id)
        raw=None
        with gevent.Timeout(self.timeout, False):
            raw = self.request.recv(16)
        if not raw:
            self.ready = False
        elif raw != session_id:
            raise ValueError("validate error(%s:%s)" % self.client_address)
        else:
            self.server.clients[session_id] = self

    def lineReceived(self, line):
        logger.debug('received a line %s' % line)

    def destroy(self):
        if self.delimiter in self.server.clients:
            del self.server.clients[self.delimiter]


class ResponseHandler(AuthHandler):

    def lineReceived(self, line):
        self.sendLine(self.makeResponse(line))

    def makeResponse(self, line):
        pass


class PullHandler(AuthHandler):

    def lineReceived(self, line):
        self.pulled(line)

    def pulled(self, line):
        pass
